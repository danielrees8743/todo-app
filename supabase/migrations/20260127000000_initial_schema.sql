-- Initial schema migration for Todo App

-- Create profiles table (extends auth.users)
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamptz,
  username text unique,
  full_name text,
  avatar_url text,
  website text,
  constraint username_length check (char_length(username) >= 3)
);

alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Create todos table
create table public.todos (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now(),
  title text not null,
  description text,
  completed boolean default false,
  priority text default 'Medium',
  due_datetime timestamptz,
  tags text[] default '{}',
  position bigint default 0,
  user_id uuid references auth.users not null default auth.uid()
);

alter table public.todos enable row level security;

create policy "Users can view their own todos"
  on todos for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own todos"
  on todos for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own todos"
  on todos for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own todos"
  on todos for delete
  using ( auth.uid() = user_id );

-- Create subtasks table
create table public.subtasks (
  id bigint generated by default as identity primary key,
  todo_id bigint references public.todos on delete cascade not null,
  title text not null,
  completed boolean default false,
  created_at timestamptz default now(),
  position bigint default 0
);

alter table public.subtasks enable row level security;

create policy "Users can view subtasks of their todos"
  on subtasks for select
  using (
    exists (
      select 1 from todos
      where todos.id = subtasks.todo_id
      and todos.user_id = auth.uid()
    )
  );

create policy "Users can insert subtasks to their todos"
  on subtasks for insert
  with check (
    exists (
      select 1 from todos
      where todos.id = subtasks.todo_id
      and todos.user_id = auth.uid()
    )
  );

create policy "Users can update subtasks of their todos"
  on subtasks for update
  using (
    exists (
      select 1 from todos
      where todos.id = subtasks.todo_id
      and todos.user_id = auth.uid()
    )
  );

create policy "Users can delete subtasks of their todos"
  on subtasks for delete
  using (
    exists (
      select 1 from todos
      where todos.id = subtasks.todo_id
      and todos.user_id = auth.uid()
    )
  );

-- Create avatars storage bucket
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

-- Storage policies for avatars
create policy "Avatar images are publicly accessible."
on storage.objects for select
using ( bucket_id = 'avatars' );

create policy "Users can upload their own avatar."
on storage.objects for insert
to authenticated
with check (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

create policy "Users can update their own avatars."
on storage.objects for update
to authenticated
using (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

create policy "Users can delete their own avatars."
on storage.objects for delete
to authenticated
using (
  bucket_id = 'avatars'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Create indexes for performance
create index todos_user_id_idx on public.todos(user_id);
create index todos_position_idx on public.todos(position);
create index subtasks_todo_id_idx on public.subtasks(todo_id);
create index subtasks_position_idx on public.subtasks(position);

-- Function to handle new user signup (auto-create profile)
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$;

-- Trigger to auto-create profile on signup
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
